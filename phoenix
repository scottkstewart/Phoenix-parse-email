#!/usr/bin/env python3
import imp
import getpass
import sys
import shelve
import os
import time
import urllib.request
import select

def getPhoenixChecker():# import phoenix checker
    # get module containing class
    phoenixModule = imp.load_source('phoenixChecker', os.getenv("HOME") + '/.PPE/phoenixChecker.py')
    #return the class
    return phoenixModule.phoenixChecker

def getPhoenixClass():# import phoenix course
    # get module containing class
    phoenixModule = imp.load_source('phoenixClass', os.getenv("HOME") + '/.PPE/phoenixClass.py')
    #return the class
    return phoenixModule.phoenixClass

def add(nocontinue):# add user to list of bots
    # open accounts database, set high recursion limit
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()

    cont = 'y'
    while cont == 'y' or cont == 'Y':# continue to ask additions until user doesn't say 'y'
        # accept user input
        username = input("Username: ")
        password = getpass.getpass("Password: ")
        email = input("Email: ")

        # instantiate bot
        bot = phoenixChecker(username, password, email)

        # shelve bot for long term storage
        accounts[username] = bot

        if nocontinue:# if nocontinue is specified, stop after one iteration
            cont = 'n'
        else:# ask for user input to continue or stop
            cont = input("Add another? (y/n): ")

    accounts.close()


def formatInput(checkType):# format input for set
    #interpret timeframe and accept interval time
    if checkType == 's' or checkType == 'S':
        return int(input("How many seconds? "))
    elif checkType == 'h' or checkType == 'H':
        return 60*60*int(input("How many hours? "))
    elif checkType == 'd' or checkType == 'D':
        return 60*60*24*int(input("how many days? "))
    else:
        return 60 * int(input("How many minutes? "))

def set(interval):# set intervals between events
    stuff = shelve.open(os.getenv("HOME") + '/.PPE/stuff')

    if interval == "-i" or interval == "":# if -i is specified or no operation specified prompt for interval
        stuff['interval'] = formatInput(input("Update interval type ((s)econd, (m)inute, (h)our, (d)ay), default minute: "))
    if interval == "-t" or interval == "":# if -t is specified or no operation specified prompt for autotry
        stuff['autotry'] = formatInput(input("Update autotry type ((s)econd, (m)inute, (h)our, (d)ay), default minute: "))

    stuff.close()


def run(botlist, quiet):# start the bots
    # open shelved data, set recursion limit
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    stuff = shelve.open(os.getenv("HOME") + '/.PPE/stuff')
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()
    phoenixClass = getPhoenixClass()

    # instantiate list of all used phoenix checkers
    bots = []
    if len(botlist) == 0:# if list of bots is empty check all in accounts database
        for key in list(accounts.keys()):
            bots.append(accounts[key])
    else:# otherwise iterate through all bots in list
        for key in botlist:
            bots.append(accounts[key])

    # checks each account, syncs with shelve, and waits for specified interval
    while True:
        # get sleep/autotry intervals
        sleepInterval = stuff['interval']
        autotryInterval = stuff['autotry']

        # check until the program exits or connects
        while True:
            try: # will exit loop and check if the script connects to phoenix without error (times out after a minute)
                r = urllib.request.urlopen('http://portal.lcps.org/',timeout=60)
                break
            except urllib.request.URLError:
                # format interval between autotries to be human readable
                if autotryInterval <= 60:
                    autotryTime = str(autotryInterval) + ' seconds'
                elif autotryInterval <= 3600:
                    autotryTime = str(autotryInterval/60) + ' minutes'
                else:
                    autotryTime = str(autotryInterval/3600) + ' hours'

                # print and read input for time specified by autotry interval
                print('Phoenix not loaded within 60 seconds. Retry? (Y/n). Will autotry in ' + autotryTime + '.')
                i, o, e = select.select([sys.stdin], [], [], autotryInterval)

                if i:# if there is an input, continue in loop if 'y', exit otherwise
                    if sys.stdin.readline().strip()[0] == 'y':
                        print('Retrying...')
                    else:
                        print('Exiting')
                        sys.exit(0)
                else:# if the program continues without input, autotry (interval is over)
                    print('Autotrying...')

        # iterate through list of bots, checking each, specifying bool echo as !quiet
        for b in bots:
            b.check(not quiet)

        # sync accounts database with checked bots
        accounts.sync()

        #sleep for specified time
        time.sleep(sleepInterval)

def output(botlist, quiet):
    # open shelved data, set recursion limit
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()

    if quiet:# if quiet, list all keys and exit
        for key in list(accounts.keys()):
            print(key)
        return

    bots = []
    # instantiate list of all used phoenix checkers
    if len(botlist) == 0:# if list of bots is empty check all in accounts datab$
        for key in list(accounts.keys()):
            bots.append(accounts[key])
    else:# otherwise iterate through all bots in list
        for key in botlist:
            bots.append(accounts[key])

    # print grades for each bot
    for bot in bots:
        bot.printGrades()


def remove(botlist):
    if len(botlist) == 0:# if no keys specified, exit
        print("No keys entered. Specify accounts to delete and run again.")
        return

    # open shelved data, set recursion limit
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()

    # iterate through keys, removing if the account exists
    for key in botlist:
        if key in accounts:
            del accounts[key]
        else:
            print("Can't delete " + key + "; account not in database.")

    # sync and close database
    accounts.sync()
    accounts.close()


def check(botlist, quiet):
    # open shelved data, set recursion limit
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()
    phoenixClass = getPhoenixClass()

    # iterate through keys, removing if the account exists
    bots = []
    if len(bots) == 0:
        for key in list(accounts.keys()):
            bots.append(accounts[key])
    else:
        for key in botlist:
            bots.append(accounts[key])
    
    # iterate through bots, checking each (includes email) if specified, updating each otherwise
    if quiet:
        for bot in bots:# update doesn't include echo or email
            bot.update()
    else:
        for bot in bots:# check but don't echo
            bot.check(False)

    # sync and close database
    accounts.sync()
    accounts.close()


# set menu for help/usage instructions
HELPMENU = """USAGE: phoenix [-h] {command [options], command [options] ...}
-h: print usage and exit
add [-n, --no-continue]: add/change users (-n or --no-continue for one user)
check [-n, --no-email] [key1 key2 ...]: check grades, default with email on change
print [-q, --quiet] [key1 key2 ...]: print all keys (-q, --quiet) or grades
set [-i, -t]: set interval between checks (-i) autotries (-t) or both (blank)
remove [key1 key2 ...]: remove specified accounts from database
run [-q, --quiet] [key1 key2 ...]: run checks; user key(s): selective; -q: no print"""

def arg_parse(args):# recursively parse argument list
    if len(args) == 0:# base case, if no arguments are left do nothing
        return
    elif args[0] == 'set':
        if len(args) != 1 and (args[1] == '-t' or args[1] == '-i'):# include option
            set(args[1])
            arg_parse(args[2:])
        else:# don't include option
            set('')
            arg_parse(args[1:])
    elif args[0] == 'add':
        if len(args) > 1 and (args[1] == '-n' or args[1] == '--no-continue'):# include nocontinue
            add(True)
            arg_parse(args[2:])
        else:# don't include nocontinue
            add(False)
            arg_parse(args[1:])
    elif args[0] == 'remove':
        for i in range(1, len(args) + 1):# count all keys, pass all as list (in$
            if i >= len(args) or not args[i].isnumeric():
                remove(args[1:i])
                arg_parse(args[i:])
    elif args[0] == 'print' or args[0] == 'run' or args[0] == 'check':
        # set boolean quiet to whether quiet output is specified
        if args[0] == 'check':
            quiet = len(args)>1 and (args[1] == '-n' or args[1] == '--no-email')
        else:
            quiet = len(args) > 1 and (args[1] == '-q' or args[1] == '--quiet')

        # if quiet tag is specified, start counting keys one later
        if quiet:
            start = 2
        else:
            start = 1

        for i in range(start, len(args) + 1):# count all keys, pass all as list to either print or run
            if i >= len(args) or not args[i].isnumeric():
                if args[0] == 'run':
                    run(args[start:i], quiet)
                elif args[0] == 'print':
                    output(args[start:i], quiet)
                else:
                    check(args[start:i], quiet)
                arg_parse(args[i:])
    else:# if it's not a valid command print the help menu
        print(HELPMENU)

if __name__ == "__main__": # main method; calls method to parse argument list ignoring script name
    arg_parse(sys.argv[1:])
