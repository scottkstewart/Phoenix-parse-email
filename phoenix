#!/usr/bin/env python3
import imp
import getpass
import sys
import shelve
import os
import time
import urllib.request
import select
import signal
from daemonize import Daemonize

def getPhoenixChecker():# import phoenix checker
    # get module containing class
    phoenixModule = imp.load_source('phoenixChecker', os.getenv("HOME") + '/.PPE/phoenixChecker.py')
    #return the class
    return phoenixModule.phoenixChecker

def getPhoenixClass():# import phoenix course
    # get module containing class
    phoenixModule = imp.load_source('phoenixClass', os.getenv("HOME") + '/.PPE/phoenixClass.py')
    #return the class
    return phoenixModule.phoenixClass

def add(nocontinue):# add user to list of bots
    # open accounts database, set high recursion limit
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()

    cont = 'y'
    while cont == 'y' or cont == 'Y':# continue to ask additions until user doesn't say 'y'
        # accept user input
        username = input("Username: ")
        password = getpass.getpass("Password: ")
        email = input("Email: ")

        # instantiate bot and shelve (prompt on overwrite)
        if not (username in accounts.keys()) or input("Account " + username + " already exists. Overwrite? (y/n): ").lower() == 'y':
            bot = phoenixChecker(username, password, email)
            accounts[username] = bot

        if nocontinue:# if nocontinue is specified, stop after one iteration
            cont = 'n'
        else:# ask for user input to continue or stop
            cont = input("Add another? (y/n): ")

    accounts.close()


def formatInput(checkType):# format input for set
    #interpret timeframe and accept interval time
    if checkType == 's' or checkType == 'S':
        return int(input("How many seconds? "))
    elif checkType == 'h' or checkType == 'H':
        return 60*60*int(input("How many hours? "))
    elif checkType == 'd' or checkType == 'D':
        return 60*60*24*int(input("how many days? "))
    else:
        return 60 * int(input("How many minutes? "))

def set(interval):# set intervals between events
    stuff = shelve.open(os.getenv("HOME") + '/.PPE/stuff')

    if interval == "-i" or interval == "":# if -i is specified or no operation specified prompt for interval
        stuff['interval'] = formatInput(input("Update interval type ((s)econd, (m)inute, (h)our, (d)ay), default minute: "))
    if interval == "-t" or interval == "":# if -t is specified or no operation specified prompt for autotry
        stuff['autotry'] = formatInput(input("Update autotry type ((s)econd, (m)inute, (h)our, (d)ay), default minute: "))

    stuff.close()

def run(botlist, quiet, verbose, quarter):# start the bots
    # open shelved data set recursion limit
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()
    phoenixClass = getPhoenixClass()

    # instantiate list of all used phoenix checkers and shelve list of keys running
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    stuff = shelve.open(os.getenv("HOME") + '/.PPE/stuff', writeback=True)
    bots = []
    if len(botlist) == 0:# if list of bots is empty check all in accounts database
        for key in list(accounts.keys()):
            bots.append(accounts[key])

        stuff['botlist'] = list(accounts.keys())
    else:# otherwise iterate through all bots in list
        stuff['botlist'] = []
        for key in botlist:
            bots.append(accounts[key])
            stuff['botlist'].append(key)
    
    # sync stuff and close all databases
    stuff.sync()
    stuff.close()    
    accounts.close()


    # checks each account, syncs with shelve, and waits for specified interval
    while True:
        # open accounts
        accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
        stuff = shelve.open(os.getenv("HOME") + '/.PPE/stuff')
        
        # get sleep/autotry intervals
        sleepInterval = stuff['interval']
        autotryInterval = stuff['autotry']

        # check until the program exits or connects
        while True:
            try: # will exit loop and check if the script connects to phoenix without error (times out after a minute)
                r = urllib.request.urlopen('http://portal.lcps.org/',timeout=60)
                break
            except urllib.request.URLError:
                # format interval between autotries to be human readable
                if autotryInterval <= 60:
                    autotryTime = str(autotryInterval) + ' seconds'
                elif autotryInterval <= 3600:
                    autotryTime = str(autotryInterval/60) + ' minutes'
                else:
                    autotryTime = str(autotryInterval/3600) + ' hours'

                # print and read input for time specified by autotry interval
                print('Phoenix not loaded within 60 seconds. Retry? (Y/n). Will autotry in ' + autotryTime + '.')
                i, o, e = select.select([sys.stdin], [], [], autotryInterval)

                if i:# if there is an input, continue in loop if 'y', exit otherwise
                    if sys.stdin.readline().strip()[0] == 'y':
                        print('Retrying...')
                    else:
                        print('Exiting')
                        sys.exit(0)
                else:# if the program continues without input, autotry (interval is over)
                    print('Autotrying...')

        # iterate through list of bots, checking each, specifying bool echo as !quiet
        for b in bots:
            # if quarter signifies all, check all quarters, otherwise check the specified quarter
            if quarter == -1:
                for i in range(1, 5):
                    b.check(not quiet, verbose, i)
            else:
                b.check(not quiet, verbose, quarter)

        # sync accounts database with checked bots
        accounts.sync()
        accounts.close()
        
        # sync stuff database (botlist), shelve time for scheduled change
        stuff['schedule'] = time.time() + sleepInterval
        stuff.close()

        #sleep for specified time
        time.sleep(sleepInterval)


def output(botlist, quiet, verbose, quarter):
    # open shelved data, set recursion limit
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    stuff = shelve.open(os.getenv("HOME") + '/.PPE/stuff')
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()
    phoenixClass = getPhoenixClass()

    if quiet:# if quiet, list all keys and exit
        for key in list(accounts.keys()):
            print(key)
        return

    bots = []
    # instantiate list of all used phoenix checkers
    if len(botlist) == 0:# if list of bots is empty check all in accounts datab$
        for key in list(accounts.keys()):
            bots.append(accounts[key])
    else:# otherwise iterate through all bots in list
        for key in botlist:
            bots.append(accounts[key])

    # print grades for each bot
    for bot in bots:
        # if all quarters is specified, print all 4 quarters, otherwise print specified quarter
        if quarter == -1:
            for i in range(1, 5):
                # pass verbosity of output
                bot.printGrades(i, verbose)
        else:
            bot.printGrades(quarter, verbose)


def remove(botlist):
    if len(botlist) == 0:# if no keys specified, exit
        print("No keys entered. Specify accounts to delete and run again.")
        return

    # open shelved data, set recursion limit
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()

    # iterate through keys, removing if the account exists
    for key in botlist:
        if key in accounts:
            del accounts[key]
        else:
            print("Can't delete " + key + "; account not in database.")

    # sync and close database
    accounts.sync()
    accounts.close()


def check(botlist, quiet, quarter):
    # open shelved data, set recursion limit
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    sys.setrecursionlimit(10000)

    # import phoenixChecker class
    phoenixChecker = getPhoenixChecker()
    phoenixClass = getPhoenixClass()

    # iterate through keys, removing if the account exists
    bots = []
    if len(bots) == 0:
        for key in list(accounts.keys()):
            bots.append(accounts[key])
    else:
        for key in botlist:
            bots.append(accounts[key])
    
    # iterate through bots, checking each (includes email) if specified, updating each otherwise
    if quiet:
        for bot in bots:# update doesn't include echo or email
            # update all urls for page
            bot.urlUpdate()
            # if all quarters are specified, update 1-4, otherwise update specified
            if quarter == -1:
                for i in range(1, 5):
                    bot.update(i)
            else:
                bot.update(quarter)
    else:
        for bot in bots:# check but don't echo
            if quarter == -1:
                for i in range(1, 5):
                    bot.check(False, False, i)
            else:
                bot.check(False, False, quarter)

    # sync and close database
    accounts.sync()
    accounts.close()

def status():# print information on status of programd 
    accounts = shelve.open(os.getenv("HOME") + '/.PPE/accounts')
    stuff = shelve.open(os.getenv("HOME") + '/.PPE/stuff')
    
    try:# try to open pid file
        pid = int(open(os.getenv("HOME") + '/.PPE/ppe.pid').read())
    except FileNotFoundError:
        print("Daemon: not currently running.")
        running = False
    else:
        print("Daemon: running (PID=" + str(pid) + ")")
        running = True
    
        # find time until check
        scheduledTime = stuff['schedule']
        timeUntilRun = int(scheduledTime - time.time())

        formTime = ""
        # get string for formatted time
        if(timeUntilRun > 60*60*24):
            formTime += " " + str(timeUntilRun//(3600*24)) + " days"
            timeUntilRun %= (3600*24)
        if(timeUntilRun > 60*60):
            formTime += " " + str(timeUntilRun//3600) + " hours"
            timeUntilRun %= 3600
        if(timeUntilRun > 60):
            formTime += " " + str(timeUntilRun//60) + " minutes"
            timeUntilRun %= 60
        formTime += " " + str(timeUntilRun) + " seconds"

        print("Next scheduled check in" + formTime + ".")

    #log bots
    print("The following bots are logged (R = running):")
    for key in accounts.keys():# iterate through all keys
        runningLetter = ''
        if running:# if it's running, iterate through all keys, adding (R) if in running botlist
            for runningKey in stuff['botlist']:
                if runningKey == key:
                    runningLetter = '(R)'
                    break
        
        print(runningLetter + '\t' + key)
    
    # close databases
    accounts.close()
    stuff.close()


def daemon_start(botlist, quarter):# start daemon w/PID ~/.PPE/ppe.pid
    try:# try to open pid file
        pid = int(open(os.getenv("HOME") + '/.PPE/ppe.pid').read())
    except FileNotFoundError:# if the file doesn't exist, start daemon
        # define action for daemon as run w/specified botlist, quiet, quarter
        daemonAction = lambda: run(botlist, True, False, quarter)
        
        # fork process to daemon
        daemon = Daemonize(app="phoenix-parse-email", pid=(os.getenv("HOME") + '/.PPE/ppe.pid'), action=daemonAction)
        print("Forking to daemon (PID file=~/.PPE/ppe.pid)...")
        daemon.start()
    else:# if the file does exist already, print message and don't fork
        print("PID already exists (" + str(pid) + "). Try 'phoenix kill'")

def daemon_exit():# kill daemon w/PID ~/.PPE/ppe.pid
    try:# try to open pid file
        pid = int(open(os.getenv("HOME") + '/.PPE/ppe.pid').read())
    except FileNotFoundError:# if not found, send a message
        print("PID not found (PPE is not currently running).")
    else:# if the file exists, send sigterm to kill it
        os.kill(pid, signal.SIGTERM)
        print("Killed PPE (PID=" + str(pid) + ").")

def get_botlist(args):# iterate through arguments to give a list of the keys following a command
    for ind, key in enumerate(args):
        if not key.isnumeric():
            return args[0:ind]
    
    return args

# set menu for help/usage instructions
HELPMENU = """phoenix [options] {command [modifiers] command [modifiers] ...}

OPTIONS:
-h, --help: print usage and exit
-Q n: applies commands to quarter n (1-4), default current, n = all for every Q
-v, --verbose: includes assigmnents while printing grades

COMMANDS:
add [-n, --no-continue]: add/change users (-n or --no-continue for one user)
check [-n, --no-email] [key1 key2 ...]: check grades, default with email on change
kill: kills daemon (started by start)
print [-q, --quiet] [key1 key2 ...]: print all keys (-q, --quiet) or grades
remove [key1 key2 ...]: remove specified accounts from database
run [-q, --quiet] [key1 key2 ...]: run checks; user key(s): selective; -q: no print
set [-i, -t]: set interval between checks (-i) autotries (-t) or both (blank)
start [key1 key2 ...]: forkes run to daemon (PID file=~/.PPE/ppe.pid); keys optional
status: prints various pieces of information relating to the program's status"""

def arg_parse(args, quarter, verbose):# recursively parse argument list based on quarter (0 = current q) and verbosity
    if len(args) == 0:# base case; if nothing is left to do, exit
        return
    elif args[0] == '-v' or args[0] == '--verbose':
        arg_parse(args[1:], quarter, True)
    elif args[0] == '-Q':# if prompted to set quarter, validate and set
        if args[1] == 'all':# all = -1
            arg_parse(args[2:], -1, verbose)
        elif args[1].isnumeric() and int(args[1]) >= 1 and int(args[1]) <= 4:# 1 <= n <= 4
            arg_parse(args[2:], int(args[1]), verbose)
        else:# if invalid, print message and end
            print("Option '-Q " + args[1] + "' not valid. See 'phoenix --help'.")
            return
    elif args[0] == '-h' or args[0] == '--help':# if prompted for help menu, print help menu and exit
        print(HELPMENU)
        return
    elif args[0] == 'status':
        status()
        arg_parse(args[1:], quarter, verbose)
    elif args[0] == 'start':
        # get botlist after argument, start daemon, and call arg_parse with the appropriate arguments
        botlist = get_botlist(args[1:])
        daemon_start(botlist, quarter)
        arg_parse(args[1+len(botlist):], quarter, verbose)
    elif args[0] == 'kill':
        # kill daemon and call arg_parse
        daemon_exit()
        arg_parse(args[1:], quarter, verbose)
    elif args[0] == 'set':
        if len(args) != 1 and (args[1] == '-t' or args[1] == '-i'):# include option
            set(args[1])
            arg_parse(args[2:], quarter, verbose)
        else:# don't include option
            set('')
            arg_parse(args[1:], quarter, verbose)
    elif args[0] == 'add':
        if len(args) > 1 and (args[1] == '-n' or args[1] == '--no-continue'):# include nocontinue
            add(True)
            arg_parse(args[2:], quarter, verbose)
        else:# don't include nocontinue
            add(False)
            arg_parse(args[1:], quarter, verbose)
    elif args[0] == 'remove':
        for i in range(1, len(args) + 1):# count all keys, pass all as list (in$
            if i >= len(args) or not args[i].isnumeric():
                remove(args[1:i])
                arg_parse(args[i:], quarter, verbose)
                return
    elif args[0] == 'print' or args[0] == 'run':
        # set boolean quiet to whether quiet output is specified
        quiet = len(args) > 1 and (args[1] == '-q' or args[1] == '--quiet')

        # if quiet tag is specified, start counting keys one later
        if quiet:
            start = 2
        else:
            start = 1
        
        # get botlist and call appropriate command
        botlist = get_botlist(args[start:])
        if args[0] == 'run':
            run(botlist, quiet, verbose, quarter)
        else:
            output(botlist, quiet, verbose, quarter)
        
        # call arg_parse with appropriate arguments
        arg_parse(args[start+len(botlist):], quarter, verbose)
    elif args[0] == 'check':
        # set boolean quiet to whether quiet output is specified
        quiet = len(args) > 1 and (args[1] == '-n' or args[1] == '--no-email')

        # if quiet tag is specified, start counting keys one later
        if quiet:
            start = 2
        else:
            start = 1
        
        # get botlist, call check, and call arg_parse
        botlist = get_botlist(args[start:])
        check(botlist, quiet, quarter)
        arg_parse(args[start+len(botlist):], quarter, verbose)
    else:# if it's not a valid command exit (-... == option)
        if args[0][0] == '-':
            print("PPE: Option '" + args[0] + "' not found. See phoenix --help'")
        else:
            print("PPE: Command '" + args[0] + "' not found. See 'phoenix --help'")
        return

if __name__ == "__main__": # main method; calls method to parse argument list ignoring script name
    if len(sys.argv) == 1:
        print("PPE: No commands entered. See 'phoenix --help'")
    else:
        arg_parse(sys.argv[1:], 0, False)
